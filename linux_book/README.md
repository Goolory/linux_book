# 这是一本笔记

## 📚 Linux内核

### 🏷 内存寻址

以x86微处理器为例，Linux内存地址

**逻辑地址**

每个逻辑地址都是有一个段(segment)和偏移量(offset或displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离。

16位长段标识符+一个32位的偏移量

处理器提供段寄存器，段寄存器的唯一目的是存放段选择符。cs(代码段寄存器)、ss(栈段)、ds(数据段寄存器)

**线性地址**

(linear addrss) 也称虚拟地址(virtual address)

是一个32位（32位机器）无符号整数，可以表示4GB的地址。线性地址通常用16进制数字表示，0x00000000到0xffffffff

**物理地址**

（physical address)

用于内存芯片级内存单元寻址。它们从微处理器的地址引脚发送到内存总线上的电信号相对应。

**内存控制单元（MMU）**

通过一种称为**分段单元**的硬件电路把一个逻辑地址转化成线性地址；接着，第二个称为**分页单元**的硬件电路把线性地址转换成一个物理地址。

**段描述符**

每个段由一个8个字节的段描述符表示，它描述了段的特征。段描述符放在全局描述符表（global descriptor Table, GDT)或局部描述符表(Local descriptor table, LDT)

通常只定义一个GDT，而每个进程除了存放在GDT中的段之外如果还需要创建附加的段，就可以有自己的LDT。

**访问段描述符**

逻辑地址由16位的段选择符和32位偏移量组成，段寄存器仅仅存放段选择符。

每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器（程序员不能控制)

**分段可以给每个进程分配不同的线性空间，分页可以把同一线性地址空间映射到不同的物理空间**

#### 分页

线性地址被分成以固定长度为单位的组，称为页。页内部连续的线性地址被映射到连续的物理地址中。

**页框**

分页单元把所有的RAM内存分成固定长度的页框。每个页框包括一个页。

**页表**

把线性地址映射到物理地址的数据结构称为页表（page table)。页表存放在主存中，并在启用分页单元之前必须有内核对页表进行适当的初始化

**常规分页**

以80386，Intel处理器的分页单元处理4KB的页

32**位线性地址**

Directory（目录）

​	最高10位

Table （页表）

​	中间10位

Offset （偏移量)

 	最低12位

线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为**页目录表**，第二步转换表称为**页表**

这是二级模式--目的是在于减少每个进程页表所需要RAM的数量。

如果使用一级页表，则要2^20个表项4MB

一级和二级表示的地址数都是一样的只不过二级模式减少了页表存储的表项，但是增加了转换的查找复杂度。

页目录项和页表项有着同样的结构：

present标志：1，页或页表在主存

##### 常规分页举例

假定内核已给一个正在运行的进程分配的线性空间范围是0x20000000到0x2003ffff

这个空间正好有64页组成

从分配给进程的线性空间地址最高10位开始（Directory,目录字段）开始。这两个地址都是以20开头，因此高10位相同，即0x080（10进制为128）。因此这两个地址的Directory字段都指向进程页目录的第129项。

中间10位（页表）从0到0x03f,(十进制0到63)，因此只有这个页表的前64个表项有意义。

假设进程需要读线程地址0x20021406中的字节。这个地址由分页单元按下面的方法处理：

1. Directory字段的0x80用于选择页目录项，此目录指向该进程的页相关页表
2. Table字段0x21用于选择页面的第0x21表项，指向页匡
3. offset字段0x406在页匡中读偏移量ox406字节。

### 🏷 进程、轻量级进程和线程

#### 进程描述符

32位进程描述符

为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。----进程描述符

Task_struct类型结构

{

​	thread_info 进程的基本信息；

​	mm_struct    指向内存描述符的指针

​	tty_struct		与进程相关的tty

​	fs_struct			当前目录

​	files_struct		指向文件描述符的指针

​	signal_struct		所接收的信号

}

#### 进程状态

可运行状态

可中断的等待状态：进程被挂起，直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源

不可中断的等待状态：把信号传递到睡眠进程不能改变它的状态。

暂停状态：进程的执行被暂停。当进程收到SIGSTOP、SIGTSTP，SIGTTIN或SIGTTOU信号后，进入暂停状态。

跟踪状态：进程的执行已由debugger程序暂停。

僵死状态：进程的执行被终止，但父进程还没有wait()或waitpid()

#### 进程链表

双链表

进程链表把所有的进程描述符连起来。每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素

进程链表的头是init_task描述符。它是所谓的0进程（孤儿进程有它收留）